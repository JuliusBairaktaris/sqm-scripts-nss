#!/bin/sh
# shellcheck disable=2086,3010,1091,3043,2034
###############################################################################
# nss-zk.qos -- HW-accelerated SQM for Qualcomm NSS (IPQ807x)
# version 20260216
#
# Flat qdisc hierarchy: nsstbl (shaper) -> nssfq_codel (AQM), per direction.
# All packet scheduling is offloaded to the NSS co-processor (accel_mode 0).
#
# Requirements:
#   - Platform:  IPQ807x (Qualcomm IPQ8074)
#   - Packages:  iproute2, tc (or tc-tiny), sqm-scripts
#   - Kmods:     kmod-qca-nss-drv-qdisc, kmod-qca-nss-drv-igs
#
# Repository: https://github.com/JuliusBairaktaris/sqm-scripts-nss
# Maintainer: Julius Bairaktaris <julius@bairaktaris.de>
#
# Credits:
#   @qosmio (https://github.com/qosmio/sqm-scripts-nss)
#   @michaelchen644 (https://forum.openwrt.org/u/michaelchen644)
#   @rickkdotnet (https://github.com/rickkdotnet/sqm-scripts-nss)
#

. /lib/functions.sh
. /lib/functions/network.sh
. "${SQM_LIB_DIR}/defaults.sh"

###############################################################################
# Hotplug guard
#
# On kernel 5.15+, bringing up the IFB interface under high load can crash
# the router when triggered by hotplug. If a qdisc is already installed on
# the IFB device, skip re-initialization entirely.
###############################################################################
if [ -n "${ACTION}" ] && [ -n "${INTERFACE}" ] && [ -n "${DEVICE}" ]; then
	DEV="ifb@${INTERFACE}"
	sqm_debug "hotplug: ${ACTION} for ${INTERFACE} (${DEVICE})"
	if $TC qdisc show dev $DEV >/dev/null 2>&1; then
		sqm_log "hotplug: qdisc already present on $DEV, skipping"
		exit 0
	fi
fi

###############################################################################
# Constants
###############################################################################

# Maximum queue depth in milliseconds. Used with speed and MTU to auto-calculate
# the fq_codel packet limit when not set by the user.
# 30ms limits initial bloat while giving CoDel ~494 packets at 200 Mbps/MTU 1518.
MAXQLIMIT_MS=30

# Floor for auto-calculated queue limit. CoDel needs enough packets to measure;
# 200 is the minimum for reliable operation.
MINLIMIT=200

###############################################################################
# Utility functions
###############################################################################

# Verify the interface has an IP before proceeding.
# PPPoE/DS-Lite/MAP interfaces may not have an IP yet at boot time;
# we detect them by protocol and wait for hotplug to re-trigger SQM.
# Static/DHCP interfaces always have IPs by the time SQM runs.
check_addr() {
	local proto iface_addr

	proto=$(uci -q get "network.${IFACE}.proto")
	case "$proto" in
	pppoe|dslite|map) ;;
	*) return 0 ;;
	esac

	network_get_ipaddr iface_addr "${IFACE}"
	if [ -z "$iface_addr" ]; then
		sqm_error "check_addr: no IP on ${IFACE} (proto=${proto}), waiting for hotplug or manual restart"
		return 1
	fi
	sqm_debug "check_addr: ${IFACE} has IP ${iface_addr} (proto=${proto})"
}

# Auto-detect L2 overhead from UCI network config.
#
# Base:    18 bytes  (14 ethernet header + 4 FCS)
# NSS:    + 4 bytes  (internal framing, always present)
# PPPoE:  +10 bytes  (8 PPPoE header + 2 PPP protocol ID)
# DS-Lite: +40 bytes (IPv6 header encapsulation)
# MAP-E:  +20 bytes  (IPv4-in-IPv6 mapping)
# VLAN:   + 4 bytes  (802.1Q tag, detected by dot in device name)
#
# Returns the overhead value on stdout.
auto_detect_overhead() {
	local proto device oh=22 # 18 ethernet + 4 NSS

	proto=$(uci -q get "network.${IFACE}.proto")
	device=$(uci -q get "network.${IFACE}.device")

	case "$proto" in
	pppoe)  oh=$((oh + 10)) ;;
	dslite) oh=$((oh + 40)) ;;
	map)    oh=$((oh + 20)) ;;
	esac

	# VLAN device names contain a dot (e.g. wan.7)
	case "$device" in
	*.*) oh=$((oh + 4)) ;;
	esac

	sqm_log "auto_detect_overhead: proto=${proto:-static} device=${device:-$IFACE} -> ${oh} bytes"
	echo $oh
}

# Calculate the fq_codel packet limit from bandwidth, MTU, and delay.
# Formula: limit = (speed_kbps * 125) * (delay_ms / 1000) / mtu
# Clamps to MINLIMIT to ensure CoDel has enough headroom.
calc_limit() {
	local speed=$1 mtu=$2 delay_ms=$3
	local limit

	limit=$(( speed * 125 * delay_ms / 1000 / mtu ))

	if [ "$limit" -lt "$MINLIMIT" ]; then
		sqm_debug "calc_limit: ${limit}p too low for CoDel, raising to ${MINLIMIT}p"
		limit=$MINLIMIT
	else
		sqm_debug "calc_limit: ${limit}p (${speed} kbps, MTU ${mtu}, ${delay_ms}ms window)"
	fi
	echo $limit
}

# Resolve effective MTU (interface MTU + overhead) for a given direction.
# Auto-detects overhead when OVERHEAD is 0 or unset.
# Prints the effective MTU on stdout.
calc_effective_mtu() {
	local direction=$1
	local mtu overhead

	mtu=$(get_mtu $IFACE)
	overhead="${OVERHEAD}"

	if [ "${overhead}" -eq 0 ] 2>/dev/null || [ -z "${overhead}" ]; then
		overhead=$(auto_detect_overhead)
		sqm_log "${direction}: overhead not configured, auto-detected ${overhead} bytes"
	fi

	echo $((mtu + overhead))
}

###############################################################################
# Qdisc setup
###############################################################################

# Add the root nsstbl (token bucket limiter) shaper.
# Args: $1=interface  $2=speed_kbps  $3=burst_duration_us  $4=mtu
add_nsstbl() {
	local iface=$1 speed=$2 burst_us=$3 mtu=$4
	local burst

	sqm_debug "add_nsstbl: ${iface} rate=${speed}kbps burst=${burst_us}us mtu=${mtu}"

	# Burst: tradeoff between CPU load and shaper strictness. The SQM default
	# of 1000us is a good sweet spot for NSS -- minimal effect either way.
	burst=$(get_burst ${mtu} ${speed} ${burst_us})
	# Round to nearest MTU multiple for clean packet boundaries.
	burst=$(( ((burst + mtu / 2) / mtu) * mtu ))

	$TC qdisc add dev $iface root handle 1: \
		nsstbl rate "${speed}kbit" burst "$burst" mtu "$mtu" accel_mode 0
}

# Add nssfq_codel as child of the root nsstbl.
# Args: $1=interface  $2=speed_kbps  $3=target  $4=limit  $5=mtu  $6=qdisc_opts  $7=ecn
#
# ECN: The tc extension accepts ecn/noecn and the kernel module forwards the
# flag to firmware (nss_codel.c: q->ecn = qopt->ecn), but testing confirms the
# NSS firmware does NOT actually perform ECN marking — ecn_mark stays 0 even
# with ECN-negotiated TCP flows and active CoDel drops. The firmware always
# drops rather than marks. (Tested: NHSS.QSDK.12.5, kernel 6.12, Feb 2026.)
#
# We still forward the SQM ECN setting for forward-compatibility: if Qualcomm
# fixes the firmware, ECN will start working without script changes.
# If tc rejects the parameter (stock iproute2), we retry without it.
add_nssfq_codel() {
	local iface=$1 speed=$2 target=$3 limit=$4 mtu=$5 opts=$6 ecn=$7
	local quantum

	local ecn_opt=""

	if [ -n "$ecn" ]; then
		ecn_opt=$(get_ecn "$ecn")
		sqm_debug "add_nssfq_codel: ECN requested: ${ecn} -> ${ecn_opt}"
	fi

	sqm_debug "add_nssfq_codel: ${iface} speed=${speed} target=${target} limit=${limit} mtu=${mtu} ecn=${ecn_opt:-none} opts=[${opts}]"

	# --- interval ---
	# Set the CoDel interval (worst-case RTT to your services). Default 100ms
	# works for most connections. Override via "interval XXms" in advanced opts.
	case "$opts" in
	*interval*) ;;
	*)
		opts="interval 100ms ${opts}"
		sqm_debug "add_nssfq_codel: no interval specified, defaulting to 100ms"
		;;
	esac

	# --- quantum ---
	# Bytes dequeued per round. At MTU, all packets have equal weight.
	# Lower quantum gives small packets (games, VoIP) higher dequeue priority.
	# At <100 Mbps, default to ~MTU/5 per bufferbloat.net best practices.
	case "$opts" in
	*quantum*) ;;
	*)
		quantum=$mtu
		if [ "$speed" -lt 100000 ]; then
			quantum=$(((mtu / 5) + 1))
			sqm_debug "add_nssfq_codel: speed <100Mbps, quantum lowered to ${quantum}"
		else
			sqm_debug "add_nssfq_codel: quantum set to MTU (${quantum})"
		fi
		opts="$(get_quantum ${quantum}) ${opts}"
		;;
	esac

	# --- flows ---
	# Number of hash buckets for flow classification. 1024 is the nssfq_codel default.
	case "$opts" in
	*flows*) ;;
	*) opts="flows 1024 ${opts}" ;;
	esac

	# shellcheck disable=2046
	# Try with ECN parameter first; fall back without if tc rejects it
	# (stock iproute2 prints "Illegal, ECN not supported" and exits 1).
	if [ -n "$ecn_opt" ]; then
		$TC qdisc add dev $iface parent 1: handle 10: nssfq_codel \
			$(get_limit "$limit") $(get_target "$target" "$speed") \
			${opts} ${ecn_opt} set_default accel_mode 0 2>/dev/null && return 0
		sqm_warn "add_nssfq_codel: tc rejected '${ecn_opt}' — install patched iproute2 for ECN control. Retrying without."
	fi

	$TC qdisc add dev $iface parent 1: handle 10: nssfq_codel \
		$(get_limit "$limit") $(get_target "$target" "$speed") \
		${opts} set_default accel_mode 0
}

###############################################################################
# Direction setup
###############################################################################

egress() {
	local mtu

	[ -z "$ETARGET" ] && ETARGET="5ms"

	mtu=$(calc_effective_mtu "egress")
	[ -z "$ELIMIT" ] && ELIMIT=$(calc_limit ${UPLINK} ${mtu} ${MAXQLIMIT_MS})

	add_nsstbl ${IFACE} ${UPLINK} ${ESHAPER_BURST_DUR_US} ${mtu} || {
		sqm_error "egress: failed to add nsstbl shaper"
		return 1
	}

	# shellcheck disable=2153
	add_nssfq_codel ${IFACE} ${UPLINK} ${ETARGET} ${ELIMIT} ${mtu} "${EQDISC_OPTS}" "${EECN}" || {
		sqm_error "egress: failed to add nssfq_codel"
		return 1
	}
}

ingress() {
	local mtu

	[ -z "$ITARGET" ] && ITARGET="5ms"

	mtu=$(calc_effective_mtu "ingress")
	[ -z "$ILIMIT" ] && ILIMIT=$(calc_limit ${DOWNLINK} ${mtu} ${MAXQLIMIT_MS})

	# Create IFB device for ingress shaping and redirect all inbound traffic to it.
	# Reuse existing IFB to avoid kernel crashes on link up under high load.
	if ! [ -e /sys/devices/virtual/net/$DEV ]; then
		$IP link add name $DEV type ifb
		sqm_log "ingress: created $DEV"
	fi
	$IP link set dev $DEV up

	# Remove stale ingress qdisc if present (deleting qdisc removes all filters).
	SILENT=1 $TC qdisc del dev $IFACE ingress 2>/dev/null

	$TC qdisc add dev $IFACE handle ffff: ingress || {
		sqm_error "ingress: failed to add ingress qdisc"
		return 1
	}

	$TC filter add dev $IFACE parent ffff: protocol all \
		u32 match u32 0 0 action nssmirred redirect dev $DEV fromdev $IFACE || {
		sqm_error "ingress: failed to add redirect filter"
		return 1
	}

	add_nsstbl ${DEV} ${DOWNLINK} ${ISHAPER_BURST_DUR_US} ${mtu} || {
		sqm_error "ingress: failed to add nsstbl shaper"
		return 1
	}

	# shellcheck disable=2153
	add_nssfq_codel ${DEV} ${DOWNLINK} ${ITARGET} ${ILIMIT} ${mtu} "${IQDISC_OPTS}" "${IECN}" || {
		sqm_error "ingress: failed to add nssfq_codel"
		return 1
	}
}

###############################################################################
# SQM lifecycle
###############################################################################

sqm_prepare_script() {
	local module

	if [ ! -d /sys/module/ifb ]; then
		insmod ifb numifbs=0 2>>"${OUTPUT_TARGET}" || {
			sqm_error "sqm_prepare_script: failed to load ifb module"
			return 1
		}
	fi

	for module in qca_nss_qdisc act_nssmirred; do
		if [ ! -d /sys/module/$module ]; then
			sqm_log "sqm_prepare_script: loading $module"
			modprobe -v $module 2>>"${OUTPUT_TARGET}" || {
				sqm_error "sqm_prepare_script: failed to load $module"
				return 1
			}
		fi
	done
}

sqm_start() {
	local protocol

	[ -n "$IFACE" ] || return 1

	network_get_protocol protocol "$IFACE"

	if [ "$protocol" = "wireguard" ]; then
		sqm_error "sqm_start: Wireguard (${IFACE}) is not supported by NSS"
		return 1
	fi

	DEV="ifb@${IFACE}"

	ipt_log_restart
	check_addr || return $?
	sqm_prepare_script || return $?

	if [ "${UPLINK}" -ne 0 ]; then
		CUR_DIRECTION="egress"
		if fn_exists egress && egress; then
			sqm_log "sqm_start: egress shaping activated"
		else
			sqm_warn "sqm_start: egress setup failed"
		fi
	else
		SILENT=1 $TC qdisc del dev ${IFACE} root 2>/dev/null
		sqm_log "sqm_start: egress shaping disabled (UPLINK=0)"
	fi

	if [ "${DOWNLINK}" -ne 0 ]; then
		CUR_DIRECTION="ingress"
		if fn_exists ingress && ingress; then
			sqm_log "sqm_start: ingress shaping activated"
		else
			sqm_warn "sqm_start: ingress setup failed"
		fi
	else
		SILENT=1 $TC qdisc del dev ${DEV} root 2>/dev/null
		sqm_log "sqm_start: ingress shaping disabled (DOWNLINK=0)"
	fi

	return 0
}

sqm_stop() {
	local module

	[ -n "$IFACE" ] || return 1

	DEV="ifb@${IFACE}"
	sqm_log "sqm_stop: tearing down SQM on ${IFACE} (${DEV})"

	# Flat hierarchy: deleting root removes nsstbl + nssfq_codel in one call.
	SILENT=1 $TC qdisc del dev $IFACE root 2>/dev/null

	# Remove ingress qdisc (and all associated filters).
	SILENT=1 $TC qdisc del dev $IFACE ingress 2>/dev/null

	# Tear down the IFB device qdisc but keep the device itself.
	# Deleting and recreating IFB under traffic can cause kernel panics on some kernels.
	if [ -e /sys/devices/virtual/net/$DEV ]; then
		$TC qdisc del dev $DEV root 2>/dev/null
		sqm_log "sqm_stop: removed $DEV qdisc (device kept for reuse)"
	fi

	# Undo any iptables rules logged during setup.
	ipt_log_rewind

	# Keep kernel modules loaded to avoid crashes on reload.
	# NSS modules are safe to leave resident and avoid potential race conditions.
	sqm_debug "sqm_stop: keeping NSS modules loaded (safer for restart)"

	return 0
}

# vim: ft=sh ts=2 sw=2 sts=2 et
